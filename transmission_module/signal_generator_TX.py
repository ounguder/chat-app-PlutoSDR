import numpy as np
import matplotlib.pyplot as plt
from utils.pulse_shape import srrc
from scipy import signal
from utils.oversample import oversample
import sys as sys
"""
    Generate a time-domain transmit signal for digital communication.

    This function takes input symbol frames and generates a time-domain
    transmit signal by oversampling, pulse shaping, and optional convolution.

    Args:
        symbolFrames (numpy.ndarray): Input array of complex symbol frames.
        txLen (int): Length of the desired transmit signal.
        oversamplingRate (int): Oversampling rate for symbol interpolation.
        halfNumberOfSymbols (int): Half the number of symbols used for pulse shaping.
        beta (float): Roll-off factor for the square-root raised cosine (SRRC) pulse.
        signalOrSymbols (bool): If True, convolve pulse-shaped symbols; otherwise, use original symbols.
        visualize (bool): If True, visualize pulse and signal using plots.

    Returns:
        numpy.ndarray: The generated complex transmit signal in time domain.

    Note:
        This function relies on external functions 'oversample' and 'srrc' for oversampling and
        square-root raised cosine (SRRC) pulse shaping, respectively. Ensure these functions are defined
        before calling 'txSignalGenerator'.

    Example:
        symbolFrames = np.array([...])  # Input complex symbol frames
        txLen = 1000                     # Desired length of transmit signal
        oversamplingRate = 4             # Oversampling factor
        halfNumberOfSymbols = 6          # Half the number of symbols for pulse shaping
        beta = 0.5                       # Roll-off factor for SRRC pulse
        signalOrSymbols = True           # Convolve pulse-shaped symbols
        visualize = True                 # Visualize pulse and signal
        mySignal = txSignalGenerator2(symbolFrames, txLen, oversamplingRate,
                                      halfNumberOfSymbols, beta, signalOrSymbols, visualize)
    """


def signal_generator_2(symbol_frames, buffer_len_TX, oversampling_rate,
                       half_number_of_symbols, beta, signal_or_symbols,
                       visualize):

    # total length of symbolFrames after oversampling
    block_len_TX = len(symbol_frames) * oversampling_rate
    # To calculate how many oversampled symbol frames can fit in one transmission
    division_result = divmod(buffer_len_TX, block_len_TX)
    symbols_real = np.append(
        np.tile(np.real(symbol_frames), division_result[0]),
        np.real(symbol_frames)[:division_result[1] + 1])
    symbols_imag = np.append(
        np.tile(np.imag(symbol_frames), division_result[0]),
        np.imag(symbol_frames)[:division_result[1] + 1])

    symbols_before_convolution = symbols_real + 1j * symbols_imag
    oversampled_symbols_real = oversample(symbols_real, oversampling_rate)
    oversampled_symbols_imag = oversample(symbols_imag, oversampling_rate)
    osaSymbols = oversampled_symbols_real + 1j * oversampled_symbols_imag
    oversampled_symbol_array_real = np.real(osaSymbols)
    oversampled_symbol_array_imag = np.imag(osaSymbols)

    # PULSE SHAPING AND CONVOLUTION
    pulse = srrc(half_number_of_symbols, beta, oversampling_rate)
    if signal_or_symbols:
        signal_real = signal.convolve(oversampled_symbol_array_real, my_pulse,
                                      'full')
        signal_imag = signal.convolve(oversampled_symbol_array_imag, my_pulse,
                                      'full')
        my_signal = signal_real + 1j * signal_imag
    else:
        my_signal = symbols_before_convolution

    # DISPLAY
    if visualize:
        my_pulse = pulse
        fig0, axs0 = plt.subplots()
        axs0.stem(pulse)

        fig1, axs1 = plt.subplots(2, 1)
        n = np.linspace(0, len(my_signal), len(my_signal), endpoint=True)
        axs1[0].set_title('Symbols')
        axs1[0].plot(oversampled_symbol_array_real,
                     'r',
                     label='Real',
                     marker='^',
                     linestyle='None',
                     markersize=6)
        axs1[0].plot(oversampled_symbol_array_imag,
                     'b',
                     label='Imag',
                     marker='v',
                     linestyle='None',
                     markersize=6)
        axs1[0].legend()
        axs1[0].grid(markevery=2)
        axs1[1].plot(n, np.real(my_signal), 'r', label='Real')
        axs1[1].plot(n, np.imag(my_signal), 'b', label='Imag')
        axs1[1].set_title('TX Signal')
    return my_signal


"""
    Generate the transmit signal using oversampling, pulse shaping, and convolution.

    Args:
        symbol_frames (np.ndarray): Symbol frames generated by `frame_generator_TX`.
        buffer_len_TX (int): Length of the transmit samples in SDR.
        oversampling_rate (int): Number of samples in one symbol.
        half_number_of_symbols (int): Number of symbols in half length of SRRC Pulse.
        beta (float): Beta parameter of SRRC Pulse.
        signal_or_symbols (int): Flag to indicate whether to return the signal or symbols.
                                 1 for signal, 0 for symbols.
        visualize (bool): Flag indicating whether to display visualization plots.
        print_data (bool): Flag indicating whether to print additional data.

    Returns:
        np.ndarray: Generated transmit signal or symbols based on the input parameters.
    """


def signal_generator(symbol_frames, buffer_len_TX, oversampling_rate,
                     half_number_of_symbols, beta, signal_or_symbols,
                     visualize, print_data):

    buffer_len_TX = buffer_len_TX
    P = oversampling_rate  # Upsamling Rate
    half_number_of_symbols = half_number_of_symbols

    oversampled_symbols_real = oversample(np.real(symbol_frames), P)
    oversampled_symbols_imag = oversample(np.imag(symbol_frames), P)

    block_len_TX = len(oversampled_symbols_real)

    div_result = divmod(buffer_len_TX, block_len_TX)
    appended_oversampled_symbols_real = np.append(
        np.tile(oversampled_symbols_real, div_result[0]),
        oversampled_symbols_real[:div_result[1]])
    appended_oversampled_symbols_imag = np.append(
        np.tile(oversampled_symbols_imag, div_result[0]),
        oversampled_symbols_imag[:div_result[1]])

    # PULSE SHAPING AND CONVOLUTION
    pulse = srrc(half_number_of_symbols, beta, P)
    my_pulse = pulse
    if print_data:
        print(f'Oversampled Symbol Array Length = {block_len_TX}')
        print(
            f'Oversampled and Repeated Symbol Array Length = {len(appended_oversampled_symbols_imag)}'
        )

    if signal_or_symbols:
        signal_real = signal.convolve(appended_oversampled_symbols_real,
                                      my_pulse, 'full')
        signal_imag = signal.convolve(appended_oversampled_symbols_imag,
                                      my_pulse, 'full')
        my_signal = signal_real + 1j * signal_imag
    else:
        my_signal = appended_oversampled_symbols_real + 1j * appended_oversampled_symbols_imag

    # DISPLAY
    if visualize:

        fig0, axs = plt.subplots(figsize=(12.8, 9.6))
        fig0.suptitle("SRRC Pulse Shape", fontsize=20)
        axs.set_ylabel("Amplitude", fontsize=16)
        axs.set_xlabel("Samples", fontsize=16)
        axs.stem(pulse)
        fig0.tight_layout()

        fig1, axs = plt.subplots(2, 1, figsize=(12.8, 9.6))
        n = np.linspace(0, len(my_signal), len(my_signal), endpoint=True)
        axs[0].set_title('Oversampled and Appended Symbol Frames', fontsize=18)
        axs[0].plot(appended_oversampled_symbols_real,
                    'r',
                    label='Real',
                    marker='^',
                    linestyle='None',
                    markersize=6)
        axs[0].plot(appended_oversampled_symbols_imag,
                    'b',
                    label='Imag',
                    marker='v',
                    linestyle='None',
                    markersize=6)
        axs[0].legend()
        axs[0].set_xlabel("Samples", fontsize=16)
        axs[0].set_ylabel("Amplitude", fontsize=16)
        axs[0].grid(markevery=2)
        axs[1].plot(n, np.real(my_signal), 'r', label='Real')
        axs[1].plot(n, np.imag(my_signal), 'b', label='Imag')
        axs[1].set_xlabel("Samples", fontsize=16)
        axs[1].set_ylabel("Amplitude", fontsize=16)
        axs[1].set_title('Tx Signal', fontsize=18)
        fig1.tight_layout()
    return my_signal